<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 학습 도구</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
        }
        .message-container {
            word-wrap: break-word;
            white-space: pre-wrap;
        }
    </style>
</head>
<body class="bg-gray-100 p-2 sm:p-6">
    <div class="container mx-auto max-w-2xl bg-white rounded-2xl shadow-xl overflow-hidden flex flex-col min-h-[95vh] w-full">
        <header class="bg-blue-600 text-white p-4 sm:p-6 rounded-t-2xl">
            <h1 class="text-2xl sm:text-3xl font-bold">AI 학습 도우미</h1>
            <p class="text-blue-200 mt-1 text-sm sm:text-base">탐구활동에 필요한 질문을 입력하면 AI가 답변해 드립니다.ver-gem-sys</p>
        </header>

        <div id="chat-container" class="flex-grow p-4 sm:p-6 overflow-y-auto space-y-4">
            <div class="flex justify-start">
                <div class="bg-gray-200 text-gray-800 p-3 rounded-xl max-w-[85%]">
                    <p>안녕하세요! 무엇을 도와드릴까요? (예: '유사과학이란 무엇인가요?')</p>
                </div>
            </div>
        </div>

        <div class="p-4 sm:p-6 border-t border-gray-200">
            <div class="flex items-end space-x-2 sm:space-x-3">
                <textarea id="question-input" rows="1" class="flex-grow resize-none rounded-xl border border-gray-300 p-3 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="여기에 질문을 입력하세요..."></textarea>
                <button id="submit-button" class="bg-blue-600 text-white p-3 rounded-xl shadow-md hover:bg-blue-700 transition-colors duration-200 whitespace-nowrap">
                    보내기
                </button>
            </div>
            
            <div id="status-message" class="mt-2 text-center text-sm hidden">
                <p id="loading-spinner" class="text-blue-500 flex items-center justify-center hidden">
                    <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                      <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    답변 생성 중...
                </p>
                <p id="error-message" class="text-red-500 hidden"></p>
            </div>
            <button id="summarize-button" class="mt-4 w-full bg-blue-500 text-white p-3 rounded-xl shadow-md hover:bg-blue-600 transition-colors duration-200 flex items-center justify-center space-x-2 hidden">
                ✨ 마지막 답변 요약하기
            </button>
        </div>
    </div>

    <script>
        // DOM 요소 가져오기
        const chatContainer = document.getElementById('chat-container');
        const questionInput = document.getElementById('question-input');
        const submitButton = document.getElementById('submit-button');
        const loadingSpinner = document.getElementById('loading-spinner');
        const errorMessage = document.getElementById('error-message');
        const summarizeButton = document.getElementById('summarize-button');
        
        // ✅ [추가된 부분] 기본 AI 역할 정의 (시스템 프롬프트)
        const baseSystemInstruction = "당신은 학생들의 **탐구 활동을 돕는 전문적인 AI 학습 도우미**입니다. 답변은 명확하고 교육적이며, 항상 **한국어로 상세하게** 응답해야 합니다. 답변에 포함된 정보는 최대한 객관적이고 사실에 기반해야 합니다.";
        
        // Gemini API 설정
        // IMPORTANT: 여기에 유효한 Gemini API 키를 입력하세요.
        const apiKey = "AIzaSyDTXZPNAIpm1tC0laI7AY-zV_7IqOu6Iuo";
        const textApiUrl = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=" + apiKey;
        const imageApiUrl = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=" + apiKey;

        let lastAiResponse = "";

        // 메시지를 채팅 컨테이너에 추가하는 함수 (변경 없음)
        function addMessage(content, sender, isSummary = false, isImage = false) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('flex');
            
            if (sender === 'user') {
                messageElement.classList.add('justify-end');
                messageElement.innerHTML = `
                    <div class="bg-blue-500 text-white p-3 rounded-xl max-w-[85%] message-container">
                        <p>${content}</p>
                    </div>
                `;
            } else { // sender === 'ai'
                messageElement.classList.add('justify-start');
                if (isImage) {
                    messageElement.innerHTML = `
                        <div class="bg-gray-200 text-gray-800 p-3 rounded-xl max-w-[85%] message-container">
                            <img src="data:image/png;base64,${content}" alt="AI generated image" class="rounded-xl w-full h-auto">
                        </div>
                    `;
                } else {
                    messageElement.innerHTML = `
                        <div class="bg-gray-200 text-gray-800 p-3 rounded-xl max-w-[85%] message-container">
                            <p>${content}</p>
                        </div>
                    `;
                }
            }
            chatContainer.appendChild(messageElement);
            chatContainer.scrollTop = chatContainer.scrollHeight;

            if (sender === 'ai' && !isSummary && !isImage) {
                lastAiResponse = content;
                summarizeButton.classList.remove('hidden');
            } else {
                summarizeButton.classList.add('hidden');
            }
        }

        // Gemini API를 호출하여 답변을 받는 함수 (텍스트)
        async function getGeminiTextResponse(prompt, systemInstruction = null) {
            let retryCount = 0;
            const maxRetries = 3;
            const baseDelay = 1000;

            while (retryCount < maxRetries) {
                try {
                    const payload = {
                        contents: [{ parts: [{ text: prompt }] }],
                        tools: [{ "google_search": {} }],
                        // systemInstruction 파라미터를 사용하여 시스템 프롬프트 적용
                        systemInstruction: systemInstruction ? { parts: [{ text: systemInstruction }] } : undefined
                    };

                    const response = await fetch(textApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        let errorDetail = `Status: ${response.status} ${response.statusText}`;
                        if (response.status === 401) {
                            errorDetail = 'API 키가 유효하지 않습니다. 코드에 API 키를 올바르게 입력했는지 확인해 주세요.';
                        } else if (response.status === 403) {
                             errorDetail = 'API 키에 이 모델에 접근할 수 있는 권한이 없습니다.';
                        } else if (response.status === 429) {
                            const delay = baseDelay * Math.pow(2, retryCount);
                            console.log(`Rate limit exceeded. Retrying in ${delay}ms...`);
                            await new Promise(res => setTimeout(res, delay));
                            retryCount++;
                            continue;
                        }
                        const errorResponseText = await response.text();
                        console.error("API error response:", errorResponseText);
                        throw new Error(`API error: ${errorDetail}`);
                    }

                    const result = await response.json();
                    const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (text) {
                        return text;
                    } else {
                        throw new Error("API response did not contain expected text.");
                    }
                } catch (error) {
                    console.error("Failed to fetch from Gemini API:", error);
                    throw error;
                }
            }
            throw new Error("Failed to fetch from Gemini API after multiple retries.");
        }

        // Gemini API를 호출하여 이미지를 받는 함수 (변경 없음)
        async function getGeminiImageResponse(prompt) {
            let retryCount = 0;
            const maxRetries = 3;
            const baseDelay = 1000;

            while (retryCount < maxRetries) {
                try {
                    const payload = {
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            responseModalities: ['TEXT', 'IMAGE']
                        }
                    };

                    const response = await fetch(imageApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        let errorDetail = `Status: ${response.status} ${response.statusText}`;
                        if (response.status === 401) {
                            errorDetail = 'API 키가 유효하지 않습니다. 코드에 API 키를 올바르게 입력했는지 확인해 주세요.';
                        } else if (response.status === 403) {
                             errorDetail = 'API 키에 이 모델에 접근할 수 있는 권한이 없습니다.';
                        } else if (response.status === 429) {
                            const delay = baseDelay * Math.pow(2, retryCount);
                            console.log(`Rate limit exceeded. Retrying in ${delay}ms...`);
                            await new Promise(res => setTimeout(res, delay));
                            retryCount++;
                            continue;
                        }
                        const errorResponseText = await response.text();
                        console.error("API error response:", errorResponseText);
                        throw new Error(`API error: ${errorDetail}`);
                    }

                    const result = await response.json();
                    const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
                    if (base64Data) {
                        return base64Data;
                    } else {
                        throw new Error("API response did not contain expected image data.");
                    }
                } catch (error) {
                    console.error("Failed to fetch from Gemini API:", error);
                    throw error;
                }
            }
            throw new Error("Failed to fetch from Gemini API after multiple retries.");
        }

        // AI 에이전트에 질문을 보내는 함수
        async function sendMessage() {
            const question = questionInput.value.trim();
            if (question === '') {
                return;
            }

            addMessage(question, 'user');
            questionInput.value = '';
            
            // 로딩 스피너 표시 및 버튼 비활성화
            loadingSpinner.classList.remove('hidden');
            submitButton.disabled = true;
            questionInput.disabled = true;
            summarizeButton.classList.add('hidden');
            errorMessage.classList.add('hidden');

            try {
                // 사용자가 이미지 생성을 요청했는지 확인
                if (question.includes('그림') || question.includes('이미지') || question.includes('그려줘')) {
                    const imageBase64 = await getGeminiImageResponse(question);
                    addMessage(imageBase64, 'ai', false, true);
                } else {
                    // ✅ [수정된 부분] baseSystemInstruction을 시스템 프롬프트로 전달
                    const aiResponseText = await getGeminiTextResponse(question, baseSystemInstruction);
                    addMessage(aiResponseText, 'ai');
                }
            } catch (error) {
                errorMessage.textContent = '답변을 가져오는 중 오류가 발생했습니다. 잠시 후 다시 시도해 주세요.';
                errorMessage.classList.remove('hidden');
            } finally {
                loadingSpinner.classList.add('hidden');
                submitButton.disabled = false;
                questionInput.disabled = false;
            }
        }

        // 마지막 AI 답변을 요약하는 함수
        async function summarizeResponse() {
            if (!lastAiResponse) {
                return;
            }

            // 로딩 스피너 표시 및 버튼 비활성화
            loadingSpinner.classList.remove('hidden');
            submitButton.disabled = true;
            questionInput.disabled = true;
            summarizeButton.disabled = true;
            errorMessage.classList.add('hidden');

            const systemInstruction = "다음 텍스트를 핵심만 요약하여 한국어로 3문장 이내로 정리해 주세요.";
            
            try {
                // 요약 기능은 별도의 시스템 프롬프트를 사용합니다.
                const summaryText = await getGeminiTextResponse(lastAiResponse, systemInstruction);
                addMessage(summaryText, 'ai', true);
            } catch (error) {
                errorMessage.textContent = '요약본을 생성하는 중 오류가 발생했습니다.';
                errorMessage.classList.remove('hidden');
            } finally {
                loadingSpinner.classList.add('hidden');
                submitButton.disabled = false;
                questionInput.disabled = false;
                summarizeButton.disabled = false;
            }
        }

        // '보내기' 버튼 클릭 이벤트 리스너
        submitButton.addEventListener('click', sendMessage);

        // '요약하기' 버튼 클릭 이벤트 리스너
        summarizeButton.addEventListener('click', summarizeResponse);

        // 'Enter' 키 누를 때 메시지 보내기
        questionInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // 새 줄이 추가되는 것을 방지
                sendMessage();
            }
        });
    </script>
</body>
</html>
